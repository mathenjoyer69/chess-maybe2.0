def evaluate_board(board):
    piece_values = {chess.PAWN: 71, chess.KNIGHT: 293, chess.BISHOP: 300,chess.ROOK: 456, chess.QUEEN: 905, chess.KING: 20000}

    num_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})

    piece_square_tables = {
        chess.PAWN: [
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 10, 20, 25, 25, 20, 10, 0,
            0, 5, 10, 20, 20, 10, 5, 0,
            5, 5, 10, 15, 15, 10, 5, 5,
            5, 0, 5, 10, 10, 5, 0, 5,
            0, 0, 0, -5, -5, 0, 0, 0,
            0, 0, 0, 5, 5, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ],
        chess.KNIGHT: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, -5, -5, -5, -5, -20, -40,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -40, -20, 5, 5, 5, 5, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50,
        ],
        chess.BISHOP: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 7, 0, 0, 0, 0, 7, -10,
            -20, -10, -10, -10, -10, -10, -10, -20,
        ],
        chess.ROOK: [
            0, 5, 10, 10, 10, 10, 5, 0,
            5, 5, 10, 10, 10, 10, 5, 5,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            5, 5, 10, 10, 10, 10, 5, 5,
            0, 5, 10, 10, 10, 10, 5, 0,
            0, 0, 5, 5, 5, 5, 0, 0,
        ],
        chess.QUEEN: [
            -20, -10, -5, 0, 0, -5, -10, -20,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 5, 10, 10, 10, 10, 5, -5,
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 5, 10, 15, 15, 10, 5, 0,
            -5, 5, 10, 10, 10, 10, 5, -5,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -20, -10, -5, 0, 0, -5, -10, -20,
        ],
        chess.KING: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -30, -30, -20, -20, -10,
            0, -10, -10, -20, -20, -10, -10, 0,
            20, 20, 10, 0, 0, 10, 20, 20,
        ]
    }
    if num_major_pieces < 4:
        piece_square_tables[chess.KING] = [
        -10, -10, -10, -10, -10, -10, -10, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -10, -10, -10, -10, -10, -10, -10,
    ]
    value = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            if piece.color == chess.WHITE:
                sign = 1
            else:
                sign = -1
            value += sign * piece_values[piece.piece_type]

            if piece.piece_type == chess.PAWN:
                value += sign * piece_square_tables[chess.PAWN][square]
            elif piece.piece_type == chess.KNIGHT:
                value += sign * piece_square_tables[chess.KNIGHT][square]
            elif piece.piece_type == chess.BISHOP:
                value += sign * piece_square_tables[chess.BISHOP][square]
            elif piece.piece_type == chess.ROOK:
                value += sign * piece_square_tables[chess.ROOK][square]
            elif piece.piece_type == chess.QUEEN:
                value += sign * piece_square_tables[chess.QUEEN][square]
            elif piece.piece_type == chess.KING:
                value += sign * piece_square_tables[chess.KING][square]

    value += 10 * (len(list(board.legal_moves)) if board.turn == chess.WHITE else -len(list(board.legal_moves)))

    if board.is_checkmate():
        return float('-inf') if board.turn == chess.WHITE else float('inf')

    return value

###############################################################################################

def evaluate_board(board):
    piece_values = {chess.PAWN: 71, chess.KNIGHT: 293, chess.BISHOP: 300,chess.ROOK: 456, chess.QUEEN: 905, chess.KING: 20000}

    num_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})

    piece_square_tables = {
        chess.PAWN: [
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 10, 20, 25, 25, 20, 10, 0,
            0, 5, 10, 20, 20, 10, 5, 0,
            5, 5, 10, 15, 15, 10, 5, 5,
            5, 0, 5, 10, 10, 5, 0, 5,
            0, 0, 0, -5, -5, 0, 0, 0,
            0, 0, 0, 5, 5, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ],
        chess.KNIGHT: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, -5, -5, -5, -5, -20, -40,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -40, -20, 5, 5, 5, 5, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50,
        ],
        chess.BISHOP: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 7, 0, 0, 0, 0, 7, -10,
            -20, -10, -10, -10, -10, -10, -10, -20,
        ],
        chess.ROOK: [
            0, 5, 10, 10, 10, 10, 5, 0,
            5, 5, 10, 10, 10, 10, 5, 5,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            5, 5, 10, 10, 10, 10, 5, 5,
            0, 5, 10, 10, 10, 10, 5, 0,
            0, 0, 5, 5, 5, 5, 0, 0,
        ],
        chess.QUEEN: [
            -20, -10, -5, 0, 0, -5, -10, -20,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 5, 10, 10, 10, 10, 5, -5,
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 5, 10, 15, 15, 10, 5, 0,
            -5, 5, 10, 10, 10, 10, 5, -5,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -20, -10, -5, 0, 0, -5, -10, -20,
        ],
        chess.KING: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -30, -30, -20, -20, -10,
            0, -10, -10, -20, -20, -10, -10, 0,
            20, 20, 10, 0, 0, 10, 20, 20,
        ]
    }
    if num_major_pieces < 4:
        piece_square_tables[chess.KING] = [
        -10, -10, -10, -10, -10, -10, -10, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -10, -10, -10, -10, -10, -10, -10,
    ]
    material_score = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())

    piece_square_bonus = 0
    for square, piece in board.piece_map().items():
        table = piece_square_tables[piece.piece_type]
        if piece.color == chess.WHITE:
            piece_square_bonus += table[square]
        else:
            piece_square_bonus += table[chess.square_mirror(square)]

    castling_bonus = 0
    if board.has_castling_rights(chess.WHITE):
        castling_bonus += 50
    if board.has_castling_rights(chess.BLACK):
        castling_bonus += 50

    early_rook_penalty = sum(35 if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.ROOK and len(board.move_stack) < 13 else 0 for move in board.move_stack)

    early_king_move_penalty = 0
    king_moves = [move for move in board.move_stack if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.KING]
    if len(king_moves) > 0:
        early_king_move_penalty += 30

    threat_bonus = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            attackers = board.attackers(not piece.color, square)
            defenders = board.attackers(piece.color, square)
            threat_bonus += len(defenders) * 10 - len(attackers) * 10

    evaluation = material_score+piece_square_bonus+castling_bonus+early_rook_penalty+early_king_move_penalty+threat_bonus
    #print(-evaluation)
    if board.turn == chess.WHITE:
        return evaluation
    else:
        return -evaluation
##################################################################################################
    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}

    num_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})

    piece_square_tables = {
        chess.PAWN: [
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 10, 20, 25, 25, 20, 10, 0,
            0, 5, 10, 20, 20, 10, 5, 0,
            5, 5, 10, 15, 15, 10, 5, 5,
            5, 0, 5, 10, 10, 5, 0, 5,
            0, 0, 0, -5, -5, 0, 0, 0,
            0, 0, 0, 5, 5, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ],
        chess.KNIGHT: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, -5, -5, -5, -5, -20, -40,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -40, -20, 5, 5, 5, 5, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50,
        ],
        chess.BISHOP: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 7, 0, 0, 0, 0, 7, -10,
            -20, -10, -10, -10, -10, -10, -10, -20,
        ],
        chess.ROOK: [
            0, 5, 10, 10, 10, 10, 5, 0,
            5, 5, 10, 10, 10, 10, 5, 5,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            5, 5, 10, 10, 10, 10, 5, 5,
            0, 5, 10, 10, 10, 10, 5, 0,
            0, 0, 5, 5, 5, 5, 0, 0,
        ],
        chess.QUEEN: [
            -20, -10, -5, 0, 0, -5, -10, -20,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 5, 10, 10, 10, 10, 5, -5,
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 5, 10, 15, 15, 10, 5, 0,
            -5, 5, 10, 10, 10, 10, 5, -5,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -20, -10, -5, 0, 0, -5, -10, -20,
        ],
        chess.KING: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -30, -30, -20, -20, -10,
            0, -10, -10, -20, -20, -10, -10, 0,
            20, 20, 10, 0, 0, 10, 20, 20,
        ]
    }
    if num_major_pieces < 4:
        piece_square_tables[chess.KING] = [
        -10, -10, -10, -10, -10, -10, -10, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -10, -10, -10, -10, -10, -10, -10,
    ]
    material_score = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())

    piece_square_bonus = 0
    for square, piece in board.piece_map().items():
        table = piece_square_tables[piece.piece_type]
        if piece.color == chess.WHITE:
            piece_square_bonus += table[square]
        else:
            piece_square_bonus += table[chess.square_mirror(square)]

    castling_bonus = 0
    if board.has_castling_rights(chess.WHITE):
        castling_bonus += 50
    if board.has_castling_rights(chess.BLACK):
        castling_bonus += 50

    early_rook_penalty = sum(35 if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.ROOK and len(board.move_stack) < 13 else 0 for move in board.move_stack)

    early_king_move_penalty = 0
    king_moves = [move for move in board.move_stack if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.KING]
    if len(king_moves) > 0:
        early_king_move_penalty += 30

    threat_bonus = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            attackers = board.attackers(not piece.color, square)
            defenders = board.attackers(piece.color, square)
            threat_bonus += len(defenders) * 10 - len(attackers) * 10

    evaluation = material_score+piece_square_bonus+castling_bonus+early_rook_penalty+early_king_move_penalty+threat_bonus
    #print(-evaluation)
    if board.turn == chess.WHITE:
        return evaluation
    else:
        return -evaluation

#############################################################################################################

    num_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})

    piece_square_tables = {
        chess.PAWN: [
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 10, 20, 25, 25, 20, 10, 0,
            0, 5, 10, 20, 20, 10, 5, 0,
            5, 5, 10, 15, 15, 10, 5, 5,
            5, 0, 5, 10, 10, 5, 0, 5,
            0, 0, 0, -5, -5, 0, 0, 0,
            0, 0, 0, 5, 5, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ],
        chess.KNIGHT: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, -5, -5, -5, -5, -20, -40,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -40, -20, 5, 5, 5, 5, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50,
        ],
        chess.BISHOP: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -10, 7, 0, 0, 0, 0, 7, -10,
            -20, -10, -10, -10, -10, -10, -10, -20,
        ],
        chess.ROOK: [
            0, 5, 10, 10, 10, 10, 5, 0,
            5, 5, 10, 10, 10, 10, 5, 5,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            10, 10, 20, 20, 20, 20, 10, 10,
            5, 5, 10, 10, 10, 10, 5, 5,
            0, 5, 10, 10, 10, 10, 5, 0,
            0, 0, 5, 5, 5, 5, 0, 0,
        ],
        chess.QUEEN: [
            -20, -10, -5, 0, 0, -5, -10, -20,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 5, 10, 10, 10, 10, 5, -5,
            0, 5, 10, 15, 15, 10, 5, 0,
            0, 5, 10, 15, 15, 10, 5, 0,
            -5, 5, 10, 10, 10, 10, 5, -5,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -20, -10, -5, 0, 0, -5, -10, -20,
        ],
        chess.KING: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -30, -30, -20, -20, -10,
            0, -10, -10, -20, -20, -10, -10, 0,
            20, 20, 10, 0, 0, 10, 20, 20,
        ]
    }
    if num_major_pieces < 4:
        piece_square_tables[chess.KING] = [
        -10, -10, -10, -10, -10, -10, -10, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 5, 5, 0, -5, -10,
        -10, -5, 0, 0, 0, 0, -5, -10,
        -10, -5, -5, -5, -5, -5, -5, -10,
        -10, -10, -10, -10, -10, -10, -10, -10,
    ]

    material_score = 0
    for piece in board.piece_map().values():
        if piece.color == chess.WHITE:
            material_score += piece_values[piece.piece_type]

    piece_square_bonus = 0
    for square , piece in board.piece_map().items():
        table = piece_square_tables[piece.piece_type]
        if piece.color == chess.WHITE:
            piece_square_bonus += table[square]

    early_king_move_penalty = 0
    king_moves = [move for move in board.move_stack if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.KING]
    if len(king_moves) > 0:
        if board.turn:
            early_king_move_penalty -= 30

    white_early_rook_penalty = sum(-35 if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.ROOK and len(board.move_stack) < 13 else 0 for move in board.move_stack)

    white_eval = material_score + piece_square_bonus + early_king_move_penalty+white_early_rook_penalty

#######################################################################################################


    black_pawn_table = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, -5, -10, 0, 0, -10, -5, 5,
        0, 0, 0, -10, -10, 0, 0, 0,
        5, 5, 10, 20, 20, 10, 5, 5,
        10, 10, 20, 40, 40, 20, 10, 10,
        30, 30, 40, 60, 60, 40, 30, 30,
        90, 90, 90, 90, 90, 90, 90, 90,
        0, 0, 0, 0, 0, 0, 0, 0
    ]

    black_knight_table = [
        -50, -40, -30, -30, -30, -30, -40, -50,
        -40, -20, 0, 0, 0, 0, -20, -40,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -40, -20, 0, 5, 5, 0, -20, -40,
        -50, -40, -30, -30, -30, -30, -40, -50,
    ]

    black_bishop_table = [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 0, 10, 15, 15, 10, 0, -10,
        -10, 5, 10, 15, 15, 10, 5, -10,
        -10, 0, 10, 10, 10, 10, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ]

    black_rook_table = [
        0, 0, 0, 5, 5, 0, 0, 0,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        5, 20, 20, 20, 20, 20, 20, 5,
        0, 0, 0, 0, 0, 0, 0, 0,
    ]

    black_queen_table = [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 5, 0, 0, 0, 0, -10,
        -10, 5, 5, 5, 5, 5, 0, -10,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -5, -5, -10, -10, -20
    ]

    black_king_table = [
        -50, -40, -30, -20, -20, -30, -40, -50,
        -30, -20, -10, 0, 0, -10, -20, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -30, 0, 0, 0, 0, -30, -30,
        -50, -30, -30, -30, -30, -30, -30, -50
    ]

###################################################################################################################################################

def evaluate_board(board):
    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}

    black_pawn_table = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, -5, -10, 0, 0, -10, -5, 5,
        0, 0, 0, -10, -10, 0, 0, 0,
        5, 5, 10, 20, 20, 10, 5, 5,
        10, 10, 20, 40, 40, 20, 10, 10,
        30, 30, 40, 60, 60, 40, 30, 30,
        90, 90, 90, 90, 90, 90, 90, 90,
        0, 0, 0, 0, 0, 0, 0, 0
    ]

    black_knight_table = [
        -50, -40, -30, -30, -30, -30, -40, -50,
        -40, -20, 0, 0, 0, 0, -20, -40,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -40, -20, 0, 5, 5, 0, -20, -40,
        -50, -40, -30, -30, -30, -30, -40, -50,
    ]

    black_bishop_table = [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 0, 10, 15, 15, 10, 0, -10,
        -10, 5, 10, 15, 15, 10, 5, -10,
        -10, 0, 10, 10, 10, 10, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ]

    black_rook_table = [
        0, 0, 0, 5, 5, 0, 0, 0,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        5, 20, 20, 20, 20, 20, 20, 5,
        0, 0, 0, 0, 0, 0, 0, 0,
    ]

    black_queen_table = [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 5, 0, 0, 0, 0, -10,
        -10, 5, 5, 5, 5, 5, 0, -10,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -5, -5, -10, -10, -20
    ]

    black_king_table = [
        -50, -40, -30, -20, -20, -30, -40, -50,
        -30, -20, -10, 0, 0, -10, -20, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -30, 0, 0, 0, 0, -30, -30,
        -50, -30, -30, -30, -30, -30, -30, -50
    ]
    white_pawn_table = [
        0,  0,  0,  0,  0,  0,  0,  0,
        10, 10, 10, 10, 10, 10, 10, 10,
        0, 40,  0,  5,  5,  0, 40,  0,
        10, 10, 20, 60, 60, 20, 10, 10,
        5,  5,  10, 20, 20, 10,  5, 5,
       -5,  0,  0, -10, -10, 0,  0, -5,
        5, -5, -10, 0,  0, -10, -5, 5,
        0,  0,  0,  0,  0,  0,  0,  0
    ]

    white_knight_table = [
        -50, -40, -30, -30, -30, -30, -40, -50,
        -40, -20, 0, 5, 5, 0, -20, -40,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -40, -20, 0, 0, 0, 0, -20, -40,
        -50, -40, -30, -30, -30, -30, -40, -50
    ]

    white_bishop_table = [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 10, 10, 5, 0, -10,
        -10, 5, 5, 10, 10, 5, 5, -10,
        -10, 0, 10, 15, 15, 10, 0, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ]

    white_rook_table = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, 20, 20, 20, 20, 20, 20, 5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        0, 0, 0, 5, 5, 0, 0, 0
    ]

    white_queen_table = [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -5, -5, -10, -10, -20
    ]

    white_king_table = [
        -50, -30, -30, -30, -30, -30, -30, -50,
        -30, -30, 0, 0, 0, 0, -30, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -20, -10, 0, 0, -10, -20, -30,
        -50, -40, -30, -20, -20, -30, -40, -50
    ]

    value = 0
    for square in chess.SQUARES:
        piece1 = board.piece_at(square)
        if piece1:
            if piece1.color == chess.WHITE:
                value += piece_values[piece1.piece_type]

                if piece1.piece_type == chess.PAWN:
                    value += white_pawn_table[square]
                elif piece1.piece_type == chess.KNIGHT:
                    value += white_knight_table[square]
                elif piece1.piece_type == chess.BISHOP:
                    value += black_bishop_table[square]
                elif piece1.piece_type == chess.ROOK:
                    value += white_rook_table[square]
                elif piece1.piece_type == chess.QUEEN:
                    value += white_queen_table[square]
                elif piece1.piece_type == chess.KING:
                    value += white_king_table[square]

            if piece1.color == chess.BLACK:
                value -= piece_values[piece1.piece_type]

                if piece1.piece_type == chess.PAWN:
                    value -= white_pawn_table[square]
                if piece1.piece_type == chess.KNIGHT:
                    value -= black_knight_table[chess.square_mirror(square)]
                if piece1.piece_type == chess.BISHOP:
                    value -= black_bishop_table[chess.square_mirror(square)]
                if piece1.piece_type == chess.ROOK:
                    value -= black_rook_table[chess.square_mirror(square)]
                if piece1.piece_type == chess.QUEEN:
                    value -= black_queen_table[chess.square_mirror(square)]
                if piece1.piece_type == chess.KING:
                    value -= black_king_table[chess.square_mirror(square)]

    value += 10*len(list(board.legal_moves)) if board.turn == chess.WHITE else -10*len(list(board.legal_moves))

    if board.is_checkmate():
        return float('inf') if board.turn == chess.WHITE else float('-inf')

    return value

#######################################################################################################################################################



def evaluate_board(board):
    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}

    if board.is_checkmate():
        return float('inf') if board.turn == chess.WHITE else float('-inf')

    black_pawn_table = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, -5, -10, 0, 0, -10, -5, 5,
        0, 0, 0, -10, -10, 0, 0, 0,
        5, 5, 10, 20, 20, 10, 5, 5,
        10, 10, 20, 40, 40, 20, 10, 10,
        30, 30, 40, 60, 60, 40, 30, 30,
        90, 90, 90, 90, 90, 90, 90, 90,
        0, 0, 0, 0, 0, 0, 0, 0
    ]

    black_knight_table = [
        -50, -40, -30, -30, -30, -30, -40, -50,
        -40, -20, 0, 0, 0, 0, -20, -40,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -40, -20, 0, 5, 5, 0, -20, -40,
        -50, -40, -30, -30, -30, -30, -40, -50,
    ]

    black_bishop_table = [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 0, 10, 15, 15, 10, 0, -10,
        -10, 5, 10, 15, 15, 10, 5, -10,
        -10, 0, 10, 10, 10, 10, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ]

    black_rook_table = [
        0, 0, 0, 5, 5, 0, 0, 0,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        5, 20, 20, 20, 20, 20, 20, 5,
        0, 0, 0, 0, 0, 0, 0, 0,
    ]

    black_queen_table = [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 5, 0, 0, 0, 0, -10,
        -10, 5, 5, 5, 5, 5, 0, -10,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -5, -5, -10, -10, -20
    ]

    black_king_table = [
        -50, -40, -30, -20, -20, -30, -40, -50,
        -30, -20, -10, 0, 0, -10, -20, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -30, 0, 0, 0, 0, -30, -30,
        -50, -30, -30, -30, -30, -30, -30, -50
    ]
    white_pawn_table = [
        0,  0,  0,  0,  0,  0,  0,  0,
        10, 10, 10, 10, 10, 10, 10, 10,
        0, 40,  0,  5,  5,  0, 40,  0,
        10, 10, 20, 60, 60, 20, 10, 10,
        5,  5,  10, 20, 20, 10,  5, 5,
       -5,  0,  0, -10, -10, 0,  0, -5,
        5, -5, -10, 0,  0, -10, -5, 5,
        0,  0,  0,  0,  0,  0,  0,  0
    ]

    white_knight_table = [
        -50, -40, -30, -30, -30, -30, -40, -50,
        -40, -20, 0, 5, 5, 0, -20, -40,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 15, 20, 20, 15, 5, -30,
        -30, 5, 10, 15, 15, 10, 5, -30,
        -40, -20, 0, 0, 0, 0, -20, -40,
        -50, -40, -30, -30, -30, -30, -40, -50
    ]

    white_bishop_table = [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 10, 10, 5, 0, -10,
        -10, 5, 5, 10, 10, 5, 5, -10,
        -10, 0, 10, 15, 15, 10, 0, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ]

    white_rook_table = [
        0, 0, 0, 0, 0, 0, 0, 0,
        5, 20, 20, 20, 20, 20, 20, 5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        -5, 0, 0, 0, 0, 0, 0, -5,
        0, 0, 0, 5, 5, 0, 0, 0
    ]

    white_queen_table = [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -5, 0, 5, 10, 10, 5, 0, -5,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -20, -10, -10, -5, -5, -10, -10, -20
    ]

    white_king_table = [
        -50, -30, -30, -30, -30, -30, -30, -50,
        -30, -30, 0, 0, 0, 0, -30, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 30, 40, 40, 30, -10, -30,
        -30, -10, 20, 30, 30, 20, -10, -30,
        -30, -20, -10, 0, 0, -10, -20, -30,
        -50, -40, -30, -20, -20, -30, -40, -50
    ]

    def king_safety(square):
        return -10 * len(list(board.attacks(square)))

    value = 0
    piece_count = 0

    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            piece_count += 1
            piece_value = piece_values[piece.piece_type]
            if piece.piece_type == chess.PAWN:
                advancement_bonus = 10 * chess.square_rank(square) if piece.color == chess.WHITE else -10 * (7 - chess.square_rank(square))
            else:
                advancement_bonus = 0

            king_safety_penalty = king_safety(square) if piece.piece_type == chess.KING else 0

            if piece.color == chess.WHITE:
                value += piece_value + advancement_bonus + king_safety_penalty
            else:
                value -= piece_value + advancement_bonus + king_safety_penalty

    legal_moves = len(list(board.legal_moves))
    value += 3 * legal_moves if board.turn == chess.WHITE else -3 * legal_moves

    if piece_count < 10:
        value += 20 if board.turn == chess.WHITE else -20

    for square in chess.SQUARES:
        piece1 = board.piece_at(square)
        if piece1:
            if piece1.color == chess.WHITE:
                value += piece_values[piece1.piece_type]

                if piece1.piece_type == chess.PAWN:
                    value += white_pawn_table[square]
                elif piece1.piece_type == chess.KNIGHT:
                    value += white_knight_table[square]
                elif piece1.piece_type == chess.BISHOP:
                    value += white_bishop_table[square]
                elif piece1.piece_type == chess.ROOK:
                    value += white_rook_table[square]
                elif piece1.piece_type == chess.QUEEN:
                    value += white_queen_table[square]
                elif piece1.piece_type == chess.KING:
                    value += white_king_table[square]

            else:
                value -= piece_values[piece1.piece_type]

                if piece1.piece_type == chess.PAWN:
                    value -= black_pawn_table[chess.square_mirror(square)]
                elif piece1.piece_type == chess.KNIGHT:
                    value -= black_knight_table[chess.square_mirror(square)]
                elif piece1.piece_type == chess.BISHOP:
                    value -= black_bishop_table[chess.square_mirror(square)]
                elif piece1.piece_type == chess.ROOK:
                    value -= black_rook_table[chess.square_mirror(square)]
                elif piece1.piece_type == chess.QUEEN:
                    value -= black_queen_table[chess.square_mirror(square)]
                elif piece1.piece_type == chess.KING:
                    value -= black_king_table[chess.square_mirror(square)]

    value += 3 * len(list(board.legal_moves)) if board.turn == chess.WHITE else -3 * len(list(board.legal_moves))

    return value

############################################################################################################################################

def minimax(board, depth, alpha, beta, maximizing):
    if depth == 0 or board.is_game_over():
        return chess_bot.evaluate(board),None

    best_move = None
    if maximizing:
        max_eval = float('-inf')
        for move in board.legal_moves:
            board.push(move)
            eval, _ = minimax(board, depth - 1, alpha, beta, False)
            if board.is_checkmate():
                board.pop()
                return eval,move
            board.pop()
            if eval > max_eval:
                max_eval = eval
                best_move = move
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return max_eval, best_move
    else:
        min_eval = float('inf')
        for move in board.legal_moves:
            board.push(move)
            eval, _ = minimax(board, depth - 1, alpha, beta, True)
            if board.is_checkmate():
                print("ariel")
                board.pop()
                return eval,move
            board.pop()
            if eval < min_eval:
                min_eval = eval
                best_move = move
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return min_eval, best_move

##################################################################################

def on_close():
    global autoplay_online_bool, analysis, autoplay_bool, custom_board_bool,bot_vs_bot,player_color
    autoplay_online_bool = autoplay_online_bool.get()
    analysis = analysis.get()
    autoplay_bool = autoplay_bool.get()
    custom_board_bool = custom_board_bool.get()
    bot_vs_bot = bot_vs_bot.get()
    player_color = player_color.get()
    root.destroy()

root = tk.Tk()

autoplay_online_bool = tk.BooleanVar(value=False)
analysis = tk.BooleanVar(value=False)
autoplay_bool = tk.BooleanVar(value=False)
custom_board_bool = tk.BooleanVar(value=False)
bot_vs_bot = tk.BooleanVar(value=False)
player_color = tk.BooleanVar(value=False)

player_color_label = tk.Label(root,text="check this to be the white pieces")
player_color_label.pack()
check_player_color = tk.Checkbutton(root,text="color",variable=player_color)
check_player_color.pack(pady=5)

autoplay_online_label = tk.Label(root, text="enable bot to move pieces on chess.com")
autoplay_online_label.pack()
check_autoplay_online = tk.Checkbutton(root, text="Autoplay Online", variable=autoplay_online_bool)
check_autoplay_online.pack(pady=5)

analysis_label = tk.Label(root, text="makes the bot play in the analysis mode of chess.com")
analysis_label.pack()
check_analysis = tk.Checkbutton(root, text="Analysis", variable=analysis)
check_analysis.pack(pady=5)

autoplay_label = tk.Label(root, text="the bot will play on the pygame screen automatically")
autoplay_label.pack()
check_autoplay = tk.Checkbutton(root, text="Autoplay", variable=autoplay_bool)
check_autoplay.pack(pady=5)

custom_board_label = tk.Label(root, text="click this to create a custom board")
custom_board_label.pack()
check_custom_board = tk.Checkbutton(root, text="custom Board", variable=custom_board_bool)
check_custom_board.pack(pady=5)

bot_vs_bot_label = tk.Label(root,text="click this if you want the bot to play against it self(it doesnt work yet)")
bot_vs_bot_label.pack()
check_bot_vs_bot = tk.Checkbutton(root,text="bot vs bot",variable=bot_vs_bot)
check_bot_vs_bot.pack(pady=5)

root.protocol("WM_DELETE_WINDOW", on_close)
root.mainloop()

print(autoplay_online_bool,autoplay_bool,analysis,custom_board_bool,bot_vs_bot)


####################################################################################################


while running and custom_board_bool:
    draw_board(flipped)
    draw_pieces(flipped)
    pygame.display.flip()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            row, col = get_square_from_pos(pygame.mouse.get_pos(), flipped)
            selected_square = chess.square(col, row)
        elif event.type == pygame.KEYDOWN:
            if selected_square is not None:
                is_shift_pressed = pygame.key.get_mods() & pygame.KMOD_SHIFT
                piece_color = chess.BLACK if is_shift_pressed else chess.WHITE
                if event.key == pygame.K_p:
                    board.set_piece_at(selected_square, chess.Piece(chess.PAWN, piece_color))
                elif event.key == pygame.K_r:
                    board.set_piece_at(selected_square, chess.Piece(chess.ROOK, piece_color))
                elif event.key == pygame.K_n:
                    board.set_piece_at(selected_square, chess.Piece(chess.KNIGHT, piece_color))
                elif event.key == pygame.K_b:
                    board.set_piece_at(selected_square, chess.Piece(chess.BISHOP, piece_color))
                elif event.key == pygame.K_q:
                    board.set_piece_at(selected_square, chess.Piece(chess.QUEEN, piece_color))
                elif event.key == pygame.K_k:
                    board.set_piece_at(selected_square, chess.Piece(chess.KING, piece_color))
                elif event.key == pygame.K_BACKSPACE:
                    board.remove_piece_at(selected_square)
                elif event.key == pygame.K_SPACE:
                    custom_board_bool = False
            else:
                print("select a square first😡")

##############################################################################################

while running and not autoplay_online_bool and not custom_board_bool and not bot_vs_bot:
    keys = pygame.key.get_pressed()
    draw_board(flipped)
    draw_pieces(flipped)
    pygame.display.flip()
    if not player_color and autoplay_bool:
        bot_move = chess_bot.get_best_move(board)
        board.push(bot_move)
        player_color = not player_color
        moves1.append(bot_move)

    if not board.legal_moves:
        running = False
        if not board.is_check():
            print("draw")
            break
        if counter % 2 == 0:
            print("black won")
            break
        else:
            print("white won")
            break

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            row, col = get_square_from_pos(pygame.mouse.get_pos(), flipped)
            square = chess.square(col, row)
            print(square)
            if selected_square is None:
                if board.piece_at(square):
                    selected_square = square
            else:
                if board.piece_at(selected_square) and board.piece_at(selected_square).piece_type == chess.PAWN:
                    if chess.square_rank(square) == 7 or chess.square_rank(square) == 0:
                        move = chess.Move(selected_square, square, promotion=chess.QUEEN)
                    else:
                        move = chess.Move(selected_square, square)
                else:
                    move = chess.Move(selected_square, square)
                if move in board.legal_moves:
                    board.push(move)
                    moves1.append(move)
                    moves_played.append(move)
                    print(move)
                    flipped = not flipped
                    counter += 1
                else:
                    print("illegal move")
                selected_square = None
            print(f"you clicked {board.piece_at(square)}")
        elif event.type == pygame.KEYDOWN and not autoplay_bool:
            if event.key == pygame.K_SPACE:
                if counter % 2 != 0:
                    best_move = chess_bot.get_best_move(board)
                    board.push(best_move)
                    moves1.append(best_move)
                    print(f"ai chose: {best_move}")
                else:
                    print("its white's turn")
                    best_move = chess_bot.get_best_move(board)
                    board.push(best_move)
            elif event.key == pygame.K_d:
                autoplay_bool = not autoplay_bool
                print("autoplay on")
            elif event.key == pygame.K_a:
                autoplay_online_bool = not autoplay_online_bool
                autoplay_bool = True
                print("autoplay online on")
        if autoplay_bool:
            if counter % 2 != 0:
                best_move = chess_bot.get_best_move(board)
                print(best_move)
                if board.legal_moves:
                    counter += 1
                    board.push(best_move)
                    moves1.append(best_move)
                    moves_played.append(best_move)
                flipped = not flipped

#################################################################################################

if autoplay_online_bool:
    sleep(3)
while running and bot_vs_bot:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    draw_board(flipped)
    draw_pieces(flipped)
    pygame.display.flip()
    keys = pygame.key.get_pressed()
    if board.is_checkmate():
        winner = "black" if counter % 2 == 0 else "white"
        print(f"{winner} won")

    if keys[pygame.K_SPACE]:
        play = not play
        print("game state: ", play)

    if play:
        best_move = chess_bot.get_best_move(board)
        move_str = str(best_move)
        move_1,move_2 = move_str[:2],move_str[2:4]
        move_1_n,move_2_n = config.square_to_number[move_1],config.square_to_number[move_2]
        moves.append(best_move)
        if not autoplay_bool:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_d:
                        board.push(best_move)
        else:
            board.push(best_move)
        sleep(0.05)
        moves_played.append(best_move)
        if autoplay_online_bool:
            autoplay_online(best_move,analysis)

print(uci_to_pgn(moves))

########################################################################################


def uci_to_pgn(uci_moves):
    pgn_moves = []
    for i, move in enumerate(uci_moves, start=1):
        if i % 2 == 1:
            pgn_moves.append(f"{(i + 1) // 2}: {move.uci()}")
        else:
            pgn_moves[-1] += f" {move.uci()}"
    return " ".join(pgn_moves)

#######################################################################################################

counter = 0
moves_played = []
while running and autoplay_online_bool and not custom_board_bool and not bot_vs_bot:
    if moves_played:
        for i in moves_played:
            autoplay_online(i,analysis)
            sleep(1)
    draw_board(flipped)
    draw_pieces(flipped)
    pygame.display.flip()

    if board.is_checkmate():
        winner = "white" if counter % 2 == 0 else "black"
        print(f"{winner} won")

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            row, col = get_square_from_pos(pygame.mouse.get_pos(), flipped)
            square = chess.square(col, row)
            if selected_square is None:
                if board.piece_at(square):
                    selected_square = square
            else:
                if board.piece_at(selected_square) and board.piece_at(selected_square).piece_type == chess.PAWN:
                    if chess.square_rank(square) == 7 or chess.square_rank(square) == 0:
                        move = chess.Move(selected_square, square, promotion=chess.QUEEN)
                    else:
                        move = chess.Move(selected_square, square)
                else:
                    move = chess.Move(selected_square, square)
                if move in board.legal_moves:
                    board.push(move)
                    counter += 1
                else:
                    print("illegal move")
                selected_square = None
            print(f"you clicked {board.piece_at(square)}")
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                if counter % 2 != 0:
                    best_move = chess_bot.get_best_move(board)
                    print(f"bot chose: {best_move}")
                    board.push(best_move)
                    sleep(1)
                    autoplay_online(best_move,analysis)
                    counter += 1
                else:
                    print("its white's turn")
                    best_move = chess_bot.get_best_move(board)
                    board.push(best_move)
                    sleep(1)
                    autoplay_online(best_move, analysis)

        if autoplay_bool:
            if counter % 2 != 0:
                counter += 1
                best_move = chess_bot.get_best_move(board)
                sleep(1)
                board.push(best_move)
                sleep(1)
                autoplay_online(best_move,analysis)

#################################################################################


def get_square_from_pos(pos, flipped):
    x, y = pos
    row, col = y // config.SQUARE_SIZE, x // config.SQUARE_SIZE
    actual_row = 7 - row if flipped else row
    actual_col = 7 - col if not flipped else col
    return actual_row, actual_col

#########################################################


def draw_pieces(flipped):
    for row in range(config.ROWS):
        for col in range(config.COLS):
            actual_row = 7 - row if flipped else row
            actual_col = 7 - col if not flipped else col

            square = chess.square(actual_col, actual_row)
            piece = board.piece_at(square)
            if piece:
                piece_symbol = piece.symbol()
                config.screen.blit(config.PIECE_IMAGES[piece_symbol], (col * config.SQUARE_SIZE, row * config.SQUARE_SIZE))

##########################################################################

def autoplay_online(move1,analysis):
    move_str = str(move1)
    if analysis:
        coordinates = config.analysis_coordinates
    else:
        coordinates = config.normal_coordinates

    first_mouse = move_str[:2]
    last_mouse = move_str[2:]
    first_m_coordinates = coordinates[first_mouse]
    last_m_coordinates = coordinates[last_mouse]
    print(first_m_coordinates,last_m_coordinates)
    pyautogui.moveTo(first_m_coordinates)
    sleep(0.5)
    pyautogui.dragTo(last_m_coordinates,button="left")

##########################################################################################


def draw_board(flipped):
    for row in range(config.ROWS):
        for col in range(config.COLS):
            color = config.LIGHT_BROWN if (row + col) % 2 == 0 else config.DARK_BROWN
            actual_row = 7 - row if flipped else row
            actual_col = 7 - col if flipped else col
            pygame.draw.rect(config.screen, color,(actual_col * config.SQUARE_SIZE, actual_row * config.SQUARE_SIZE, config.SQUARE_SIZE, config.SQUARE_SIZE))

###################################################################

    def handle_spacebar(self):
        best_move = self.bot.get_best_move(self.board)
        if best_move:
            print(f"Bot chose: {best_move}")
            self.board.push(best_move)
            self.moves_played.append(best_move)
            sleep(1)
            self.autoplay_online(best_move, self.analysis)
            self.counter += 1